// Code generated by sysl DO NOT EDIT.
package petdemo

import (
	"context"
	"fmt"
	"log"
	"os"
	"os/signal"
	"syscall"
	"time"

	"github.com/anz-bank/sysl-go/common"
	"github.com/anz-bank/sysl-go/config"
	"github.com/anz-bank/sysl-go/core"
	"github.com/anz-bank/sysl-go/handlerinitialiser"

	"github.com/anz-bank/sysl-go-demo/internal/gen/pkg/servers/Petdemo/petstore"
	"github.com/anz-bank/sysl-go-demo/internal/gen/pkg/servers/Petdemo/pokeapi"
)

// DownstreamClients for Petdemo
type DownstreamClients struct {
	petstoreClient *petstore.Client
	pokeapiClient  *pokeapi.Client
}

// BuildDownstreamClients ...
func BuildDownstreamClients(ctx context.Context, hooks *core.Hooks) (*DownstreamClients, error) {
	cfg := config.GetDefaultConfig(ctx)
	downstreamConfig := cfg.GenCode.Downstream.(*DownstreamConfig)
	if downstreamConfig == nil {
		downstreamConfig = &DownstreamConfig{}
	}
	var err error
	petstoreHTTPClient, petstoreHTTPURL, err := core.BuildDownstreamHTTPClient(
		ctx,
		"petstore",
		hooks,
		&downstreamConfig.Petstore,
	)
	if err != nil {
		return nil, err
	}
	petstoreClient := &petstore.Client{
		Client:  petstoreHTTPClient,
		URL:     petstoreHTTPURL,
		Headers: downstreamConfig.Petstore.Headers,
	}

	pokeapiHTTPClient, pokeapiHTTPURL, err := core.BuildDownstreamHTTPClient(
		ctx,
		"pokeapi",
		hooks,
		&downstreamConfig.Pokeapi,
	)
	if err != nil {
		return nil, err
	}
	pokeapiClient := &pokeapi.Client{
		Client:  pokeapiHTTPClient,
		URL:     pokeapiHTTPURL,
		Headers: downstreamConfig.Pokeapi.Headers,
	}

	return &DownstreamClients{
		petstoreClient: petstoreClient,
		pokeapiClient:  pokeapiClient,
	}, err
}

// Serve starts the server.
//
// createService must be a function with the following signature:
//
//    func(ctx context.Context, config AppConfig) (*petdemo.ServiceInterface, *core.Hooks, error)
//
// where AppConfig is a type defined by the application programmer to
// hold application-level configuration.
//
// For a quick start, copy main.go.sample from the same directory as this
// file into its own package directory, rename it to main.go, and run it.
func Serve(
	ctx context.Context,
	createService interface{},
) {
	srv, err := NewServer(ctx, createService)
	switch err.(type) {
	case core.ErrDisplayHelp:
		return
	case nil:
		signalChan := make(chan os.Signal, 1)
		signal.Notify(signalChan, syscall.SIGINT, syscall.SIGTERM)

		errChan := make(chan error, 1)
		go func() {
			defer func() {
				if r := recover(); r != nil {
					errChan <- fmt.Errorf("Server panic: %v", r)
				}
			}()

			errChan <- srv.Start()
		}()

		select {
		case <-signalChan:
			err = srv.GracefulStop()
		case err = <-errChan:
		}
	}

	if err != nil {
		log.Fatal(err)
	}
}

// NewServer creates a new application server.
//
// createService must be a function with the following signature:
//
//    func(ctx context.Context, config AppConfig) (*petdemo.ServiceInterface, *core.Hooks, error)
//
// where AppConfig is a type defined by the application programmer to
// hold application-level configuration.
func NewServer(
	ctx context.Context,
	createService interface{},
) (core.StoppableServer, error) {
	return core.NewServer(
		ctx,
		&DownstreamConfig{}, createService, &ServiceInterface{},
		func(
			ctx context.Context,
			serviceIntf interface{},
			hooks *core.Hooks,
		) (core.Manager, *core.GrpcServerManager, error) {
			serviceInterface := serviceIntf.(*ServiceInterface)
			cfg := config.GetDefaultConfig(ctx)

			if hooks == nil {
				hooks = &core.Hooks{}
			}

			var downstream *DownstreamConfig
			var is bool
			if downstream, is = cfg.GenCode.Downstream.(*DownstreamConfig); !is || downstream == nil {
				downstream = &DownstreamConfig{
					ContextTimeout: 30 * time.Second,
				}
			}

			genCallbacks := common.NewCallbackV2(
				&cfg.GenCode,
				downstream.ContextTimeout,
				hooks.MapError,
				hooks.AddHTTPMiddleware,
			)

			clients, err := BuildDownstreamClients(ctx, hooks)
			if err != nil {
				return nil, nil, err
			}
			serviceHandler, err := NewServiceHandler(
				ctx,
				hooks,
				genCallbacks,
				serviceInterface,
				clients.petstoreClient,
				clients.pokeapiClient,
			)
			if err != nil {
				return nil, nil, err
			}

			// Construct a GrpcServerManager to wrap our serviceHandler.
			var grpcPublicServerConfig *config.GRPCServerConfig = &cfg.GenCode.Upstream.GRPC

			// Here we allow the grpc.ServerOption configuration to be optionally extended or overridden.
			// See the documentation of core.Hooks for more information.
			grpcServerOptions, err := core.ResolveGrpcServerOptions(ctx, hooks, grpcPublicServerConfig)
			if err != nil {
				return nil, nil, err
			}

			// TODO make it possible to disable handlers through configuration.
			enabledGrpcHandlers := []handlerinitialiser.GrpcHandlerInitialiser{}

			grpcManager := core.GrpcServerManager{
				GrpcServerOptions:      grpcServerOptions,
				EnabledGrpcHandlers:    enabledGrpcHandlers,
				GrpcPublicServerConfig: grpcPublicServerConfig,
			}

			libraryConfig := &(cfg.Library)
			var adminServerConfig *config.CommonHTTPServerConfig = nil
			if cfg.Admin != nil {
				adminServerConfig = &cfg.Admin.HTTP
			}
			var publicServerConfig *config.UpstreamConfig = nil
			// TODO make it possible to disable handlers through configuration.
			enabledHandlers := []handlerinitialiser.HandlerInitialiser{}

			// Construct a HTTPManager to wrap our HandlerInitialiser AKA ServiceRouter.
			// TODO standardise terminology / generally refactor.
			handlerInitialiser := NewServiceRouter(genCallbacks, serviceHandler)
			enabledHandlers = append(enabledHandlers, handlerInitialiser)
			publicServerConfig = &(cfg.GenCode.Upstream)
			restManager := core.NewHTTPManagerShim(libraryConfig, adminServerConfig, publicServerConfig, enabledHandlers, hooks.AddAdminHTTPMiddleware)
			return restManager, &grpcManager, nil
		},
	)
}
